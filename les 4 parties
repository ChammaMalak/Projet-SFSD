#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NOM_FICHIER 20
#define BLOCK_SIZE 256
#define MAX_FIELDS 10
#define MAX_BLOCS 10
#define MAX_RECORDS 100

// Structure pour un enregistrement
typedef struct Record {
    int id; // Identifiant unique
    char *data; // Pointeur pour des données de taille variable
    struct Record *next; // Pour le mode chaîné
} Record;

// Structure pour un bloc de la mémoire
typedef struct {
    int est_occupe; // 0 libre, 1 occupé
    char nom_fichier[MAX_NOM_FICHIER];
    int nombre_enregistrements; // Nb d'enregistrements dans le bloc
    Record *enregistrements; // Pointeur vers les enregistrements  
} BlocMemoire;

// Structure pour représenter la mémoire secondaire
typedef struct {
    BlocMemoire *blocs;
    int nombre_blocs;
} MemoireSecondaire;

// Structure pour les métadonnées d'un fichier
typedef struct {
    char filename[MAX_NOM_FICHIER];
    int totalBlocks;
    int totalRecords;
    int firstBlock;
    int globalMode; // Mode d'organisation globale
    int internalMode; // Mode d'organisation interne
} Metadata;

// Structure pour un fichier de données
typedef struct {
    Record records[MAX_RECORDS];
    int recordCount;
    Record *head; // Tête de la liste pour le mode chaîné
} DataFile;

// Structure pour le système de fichiers
typedef struct {
    DataFile dataFiles[MAX_BLOCS];
    Metadata metadata[MAX_BLOCS];
    int totalFiles;
} FileSystem;
**// Fonction d'initialisation de la memoire secondaire
MemoireSecondaire* initialiser_disque(int nombre_blocs ) {
    MemoireSecondaire *memoire = (MemoireSecondaire *)malloc(sizeof(MemoireSecondaire));
    if (!memoire) {
        printf("Erreur : memoire insuffisante pour creer la structure de la memoire secondaire.\n");
        return NULL;
    }

    memoire->blocs = (BlocMemoire *)malloc(nombre_blocs * sizeof(BlocMemoire));
    if (!memoire->blocs) {
        printf("Erreur : memoire insuffisante pour allouer les blocs.\n");
        free(memoire);
        return NULL;
    }

    memoire->nombre_blocs = nombre_blocs;
   

    for (int i = 0; i < nombre_blocs; i++) {
        memoire->blocs[i].est_occupe = 0;
        strcpy(memoire->blocs[i].nom_fichier, "");
        memoire->blocs[i].nombre_enregistrements = 0;
         memoire->blocs[i].enregistrements = (Enregistrement *)malloc(MAX_BLOCS * sizeof(Enregistrement)); // Allocation pour les enregistrements
    }

    return memoire;
}
// Fonction de compactage avec buffer
void compacter_disque(MemoireSecondaire *memoire) {
    int index_libre = 0;
    BlocMemoire buffer;

    for (int i = 0; i < memoire->nombre_blocs; i++) {
        if (memoire->blocs[i].est_occupe) {
            if (i != index_libre) {
                // Utiliser un buffer temporaire pour le deplacement
                buffer = memoire->blocs[i];
                memoire->blocs[index_libre] = buffer;

                // Remettre l'ancien bloc a l'etat libre
                memoire->blocs[i].est_occupe = 0;
                strcpy(memoire->blocs[i].nom_fichier, "");
                memoire->blocs[i].nombre_enregistrements = 0;
            }
            index_libre++;
        }
    }
}

// Fonction de vidage de la mémoire
void vider_disque(MemoireSecondaire *memoire) {
    for (int i = 0; i < memoire->nombre_blocs; i++) {
        memoire->blocs[i].est_occupe = 0;
        strcpy(memoire->blocs[i].nom_fichier, "");
        memoire->blocs[i].nombre_enregistrements = 0;
    }
}

// Fonction d'affichage de l'etat de la memoire avec buffer
void afficher_etat_disque(MemoireSecondaire *memoire) {
   printf("\nEtat de la mémoire secondaire :\n");
    for (int i = 0; i < memoire->nombre_blocs; i++) {
        printf("Bloc %d : %s, Enregistrements : %d\n", i, memoire->blocs[i].nom_fichier, memoire->blocs[i].nombre_enregistrements);
        for (int j = 0; j < memoire->blocs[i].nombre_enregistrements; j++) {
            printf("  Enregistrement ID %d : %s\n", memoire->blocs[i].enregistrements[j].id, memoire->blocs[i].enregistrements[j].data);
        }
    }
}
// Fonction pour libérer la mémoire
void liberer_memoire(MemoireSecondaire *memoire) {
    for (int i = 0; i < memoire->nombre_blocs; i++) {
        for (int j = 0; j < memoire->blocs[i].nombre_enregistrements; j++) {
            free(memoire->blocs[i].enregistrements[j].data); // Libération des données
        }
        free(memoire->blocs[i].enregistrements); // Libération des enregistrements
    }
    free(memoire->blocs);
    free(memoire);
}
// Initialiser le système de fichiers
void initFileSystem(FileSystem *fs) {
    fs->totalFiles = 0;
}

// Fonction pour créer un fichier de données
void createDataFile(FileSystem *fs) {
    if (fs->totalFiles >= MAX_BLOCKS) {
        printf("Erreur : Limite de fichiers atteinte.\n");
        return;
    }

    Metadata newMetadata;
    printf("Entrez le nom du fichier : ");
    scanf("%s", newMetadata.filename);
    printf("Entrez le nombre d'enregistrements : ");
    scanf("%d", &newMetadata.totalRecords);
    printf("Entrez le mode d'organisation globale 1 pour contiguë 2 pour chaînée) : ");
    scanf("%d", newMetadata.globalMode);
    printf("Entrez le mode d'organisation interne 1 pour triée 2 pour non triée) : ");
    scanf("%d", newMetadata.internalMode);

    newMetadata.totalBlocks = (newMetadata.totalRecords * sizeof(Record) + BLOCK_SIZE - 1) / BLOCK_SIZE;
    newMetadata.firstBlock = fs->totalFiles; // Adresse du premier bloc

    DataFile newFile;
    newFile.recordCount = 0;
    fs->dataFiles[fs->totalFiles] = newFile;
    fs->metadata[fs->totalFiles] = newMetadata;
    fs->totalFiles++;

    printf("Fichier %s créé avec succès.\n", newMetadata.filename);
}

// Fonction pour charger un fichier (allocation des blocs)
void loadFile(FileSystem *fs, const char *filename) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
            printf("Chargement du fichier %s...\n", filename);
            // Simuler l'allocation de blocs (ici, on ne fait rien de concret)
            printf("Fichier %s chargé avec succès. Taille : %d blocs.\n", filename, fs->metadata[i].totalBlocks);
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}

 void insertRecord(FileSystem *fs, const char *filename) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
            if (fs->metadata[i].globalMode==1) {
                // Vérifier si la limite est atteinte
                if (fs->dataFiles[i].recordCount >= fs->dataFiles[i].maxRecords) {
                    printf("Erreur : Limite d'enregistrements atteinte pour %s.\n", filename);
                    return;
                }

                // Créer un nouvel enregistrement
                Record newRecord;
                newRecord.id = fs->dataFiles[i].recordCount + 1; // ID unique
                // Allocation pour les champs(mode contigue)
                newRecord.fields = malloc(MAX_FIELDS * sizeof(char *));
                for (int j = 0; j < MAX_FIELDS; j++) {
                    newRecord.fields[j] = malloc(BLOCK_SIZE * sizeof(char)); // Allocation pour chaque champ
                    printf("Entrez le champ %d : ", j + 1);
                    scanf("%s", newRecord.fields[j]); // Copie directe
                }
                // Remplir les champs
                char buffer[BLOCK_SIZE];
                for (int j = 0; j < MAX_FIELDS; j++) {
                    printf("Entrez le champ %d : ", j + 1);
                    scanf("%s", buffer);
                    strncpy(newRecord.fields[j], buffer, BLOCK_SIZE);
                }

                // Ajouter au tableau
                fs->dataFiles[i].records[fs->dataFiles[i].recordCount] = newRecord;
                fs->dataFiles[i].recordCount++;
                printf("Enregistrement ajouté avec succès à %s (mode contigu).\n", filename);
            } else if (fs->metadata[i].globalMode==2) {
                // Créer un nouvel enregistrement en mémoire dynamique
                Record *newRecord = (Record *)malloc(sizeof(Record));
                if (!newRecord) {
                    printf("Erreur : Échec de l'allocation de mémoire.\n");
                    return;
                }
                newRecord->id = (fs->dataFiles[i].head == NULL) ? 1 : fs->dataFiles[i].recordCount + 1;
                 // Allocation pour les champs(mode chainee)
                 newRecord->fields = malloc(MAX_FIELDS * sizeof(char *));
                for (int j = 0; j < MAX_FIELDS; j++) {
                    newRecord->fields[j] = malloc(BLOCK_SIZE * sizeof(char));
                    printf("Entrez le champ %d : ", j + 1);
                    scanf("%s", newRecord->fields[j]);
                }
                newRecord->next = NULL; 
                

                // Ajouter à la liste chaînée
                if (fs->dataFiles[i].head == NULL) {
                    fs->dataFiles[i].head = newRecord; // Premier élément
                } else {
                    Record *current = fs->dataFiles[i].head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newRecord; // Ajouter à la fin
                }

                fs->dataFiles[i].recordCount++;
                printf("Enregistrement ajouté avec succès à %s (mode chaîné).\n", filename);
            }
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}
   void searchRecord(FileSystem *fs, const char *filename, int id) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
            if (fs->metadata[i].globalMode==1) {
                // Recherche en mode contigu
                for (int j = 0; j < fs->dataFiles[i].recordCount; j++) {
                    if (fs->dataFiles[i].records[j].id == id) {
                        printf("Enregistrement trouvé dans %s (mode contigu) :\n", filename);
                        printf("ID : %d\n", fs->dataFiles[i].records[j].id);
                        for (int k = 0; k < MAX_FIELDS; k++) {
                            printf("Champ %d : %s\n", k + 1, fs->dataFiles[i].records[j].fields[k]);
                           return;
                    }
                }
                printf("Enregistrement avec ID %d non trouvé dans %s (mode contigu).\n", id, filename);
            } else if (fs->metadata[i].globalMode==2) {
                // Recherche en mode chaîné
                Record *current = fs->dataFiles[i].head;
                while (current != NULL) {
                    if (current->id == id) {
                        printf("Enregistrement trouvé dans %s (mode chaîné) :\n", filename);
                        printf("ID : %d\n", current->id);
                        for (int k = 0; k < MAX_FIELDS; k++) {
                            printf("Champ %d : %s\n", k + 1, current->fields[k]);
                            return;
                    }
                    current = current->next;
                }
                printf("Enregistrement avec ID %d non trouvé dans %s (mode chaîné).\n", id, filename);
                return;
        }
    } }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}
     // Fonction pour supprimer un enregistrement (logique)
  void deleteRecordloqique(FileSystem *fs, const char *filename, int id) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
       if (fs->metadata[i].globalMode==1) {
                // Recherche en mode contigu
            for (int j = 0; j < fs->dataFiles[i].recordCount; j++) {
                if (fs->dataFiles[i].records[j].id == id) {
                    // Marquer l'enregistrement comme supprimé
                    fs->dataFiles[i].records[j].id = -1; // ID négatif pour indiquer suppression
                    printf("Enregistrement avec ID %d marqué comme supprimé dans %s.\n", id, filename);
                    return;
                }
            }
            printf("Enregistrement avec ID %d non trouvé dans %s.\n", id, filename);
            return;     

     } else if (fs->metadata[i].globalMode==2) {
                // Recherche en mode chaîné
                Record *current = fs->dataFiles[i].head;
                while (current != NULL) {
                    if (current->id == id) {
                        // Marquer l'enregistrement comme supprimé
                    fs->dataFiles[i].records[j].id = -1; // ID négatif pour indiquer suppression
                    printf("Enregistrement avec ID %d marqué comme supprimé dans %s (mode chaîné).\n", id, filename);
                        return;
                    }
                    current = current->next;
                }
                printf("Enregistrement avec ID %d non trouvé dans %s .\n", id, filename);
                return;
        }
    } }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}      
      

     void deleteRecord(FileSystem *fs, const char *filename, int id) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {

           if (fs->metadata[i].globalMode==1) {
                // Recherche en mode contigu

            int recordIndex = -1;

            // Rechercher l'enregistrement à supprimer
            for (int j = 0; j < fs->dataFiles[i].recordCount; j++) {
                if (fs->dataFiles[i].records[j].id == id) {
                    recordIndex = j; // Enregistrement trouvé
                    break;
                }
            }

            // Si l'enregistrement n'est pas trouvé
            if (recordIndex == -1) {
                printf("Erreur : Enregistrement avec ID %d non trouvé dans %s.\n", id, filename);
                return;
            }

            // Supprimer l'enregistrement en décalant les suivants
            for (int j = recordIndex; j < fs->dataFiles[i].recordCount - 1; j++) {
                fs->dataFiles[i].records[j] = fs->dataFiles[i].records[j + 1];
            }

            // Réduire le compteur d'enregistrements
            fs->dataFiles[i].recordCount--;
            printf("Enregistrement avec ID %d supprimé avec succès de %s.\n", id, filename);
            return;
        } else if (fs->metadata[i].globalMode==2) {
    
            if (fs->dataFiles[i].head == NULL) {
                printf("Erreur : Aucun enregistrement à supprimer dans %s.\n", filename);
                return;
            }

            Record *current = fs->dataFiles[i].head;
            Record *previous = NULL;

            // Parcourir la liste chaînée
            while (current != NULL) {
                if (current->id == id) { // Si l'enregistrement est trouvé
                    if (previous == NULL) {
                        // Cas 1 : Suppression de la tête de la liste
                        fs->dataFiles[i].head = current->next;
                    } else {
                        // Cas 2 : Suppression au milieu ou à la fin de la liste
                        previous->next = current->next;
                    }

                    // Libérer la mémoire de l'enregistrement
                    free(current);
                    fs->dataFiles[i].recordCount--; // Décrémenter le compteur d'enregistrements
                    printf("Enregistrement avec ID %d supprimé avec succès de %s.\n", id, filename);
                    return;
                }

                // Avancer dans la liste
                previous = current;
                current = current->next;
            }

            // Si l'enregistrement n'est pas trouvé
            printf("Erreur : Enregistrement avec ID %d non trouvé dans %s.\n", id, filename);
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}
// Fonction pour défragmenter un fichier
void defragmentFile(FileSystem *fs, const char *filename) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
            // Réorganiser les enregistrements pour libérer l'espace
            int validIndex = 0;
            for (int j = 0; j < fs->dataFiles[i].recordCount; j++) {
                if (fs->dataFiles[i].records[j].id != -1) {
                    fs->dataFiles[i].records[validIndex++] = fs->dataFiles[i].records[j];
                }
            }
            fs->dataFiles[i].recordCount = validIndex;
            printf("Défragmentation de %s effectuée avec succès.\n", filename);
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}

// Fonction pour renommer un fichier
void renameFile(FileSystem *fs, const char *oldName, const char *newName) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, oldName) == 0) {
            strcpy(fs->metadata[i].filename, newName);
            printf("Fichier renommé de %s à %s.\n", oldName, newName);
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", oldName);
}

// Fonction pour supprimer un fichier
void deleteFile(FileSystem *fs, const char *filename) {
    for (int i = 0; i < fs->totalFiles; i++) {
        if (strcmp(fs->metadata[i].filename, filename) == 0) {
            // Déplacer tous les fichiers suivants
            for (int j = i; j < fs->totalFiles - 1; j++) {
                fs->dataFiles[j] = fs->dataFiles[j + 1];
                fs->metadata[j] = fs->metadata[j + 1];
            }
            fs->totalFiles--;
            printf("Fichier %s supprimé avec succès.\n", filename);
            return;
        }
    }
    printf("Erreur : Fichier %s non trouvé.\n", filename);
}
